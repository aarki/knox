package main

import (
    "bufio"
	"crypto/tls"
    //"crypto/x509"
	"encoding/json"
    "fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"os"
	"os/user"
    "strings"
    "syscall"
	"time"

	"github.com/pinterest/knox"
	"github.com/pinterest/knox/client"
    
    "golang.org/x/crypto/ssh/terminal"
)

// certPEMBlock is the certificate signed by the CA to identify the machine using the client
// (Should be pulled from a file or via another process)
const certPEMBlock = `-----BEGIN CERTIFICATE-----
MIIB7TCCAZOgAwIBAgIDEAAEMAoGCCqGSM49BAMCMFExCzAJBgNVBAYTAlVTMQsw
CQYDVQQIEwJDQTEYMBYGA1UEChMPTXkgQ29tcGFueSBOYW1lMRswGQYDVQQDExJ1
c2VPbmx5SW5EZXZPclRlc3QwHhcNMTgwMzAyMDI1NjEyWhcNMTkwMzAyMDI1NjEy
WjBKMQswCQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExGDAWBgNVBAoMD015IENvbXBh
bnkgTmFtZTEUMBIGA1UEAwwLZXhhbXBsZS5jb20wWTATBgcqhkjOPQIBBggqhkjO
PQMBBwNCAAQQTbdQNoE5/j6mgh4HAdbgPyGbuzjpHI/x34p6qPojduUK+ifUW6Mb
bS5Zumjh31K5AmWYt4jWfU82Sb6sxPKXo2EwXzAJBgNVHRMEAjAAMAsGA1UdDwQE
AwIF4DBFBgNVHREEPjA8hhxzcGlmZmU6Ly9leGFtcGxlLmNvbS9zZXJ2aWNlggtl
eGFtcGxlLmNvbYIPd3d3LmV4YW1wbGUuY29tMAoGCCqGSM49BAMCA0gAMEUCIQDO
TaI0ltMPlPDt4XSdWJawZ4euAGXJCyoxHFs8HQK8XwIgVokWyTcajFoP0/ZfzrM5
SihfFJr39Ck4V5InJRHPPtY=
-----END CERTIFICATE-----`

// keyPEMBlock is the private key that should only be available on the machine running this client
// (Should be pulled from a file or via another process)
const keyPEMBlock = `-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIDHDjs9Ug8QvsuKRrtC6QUmz4u++oBJF2VtCZe9gYyzOoAoGCCqGSM49
AwEHoUQDQgAEEE23UDaBOf4+poIeBwHW4D8hm7s46RyP8d+Keqj6I3blCvon1Fuj
G20uWbpo4d9SuQJlmLeI1n1PNkm+rMTylw==
-----END EC PRIVATE KEY-----`

type Config struct {
    ServerInfo struct {
        Name string `json:"host"`
        Port string `json:"port"`
    }
}

// tokenEndpoint and clientID are used by "knox login" if your oauth client supports password flows.
const tokenEndpoint = "https://oauth.token.endpoint.used.for/knox/login"
const clientID = ""

// keyFolder is the directory where keys are cached
const keyFolder = "/var/lib/knox/v0/keys/"

// authTokenResp is the format of the OAuth response generated by "knox login"
type authTokenResp struct {
	AccessToken string `json:"access_token"`
	Error       string `json:"error"`
}

// getCert returns the cert in the tls.Certificate format. This should be a config option in prod.
func getCert() (tls.Certificate, error) {
	return tls.X509KeyPair([]byte(certPEMBlock), []byte(keyPEMBlock))
}

func getConfig() (*Config) {
    errLogger := log.New(os.Stderr, "", 0)
	u, err := user.Current()
	if err != nil {
        os.Exit(1)
	}
    configFilePath := u.HomeDir + "/.knox_client_config.json"
	file, err := os.Open(configFilePath)
    defer file.Close()
	if err != nil {
        errLogger.Fatal("Could not read config file " + configFilePath + ": ", err)
	}
    conf := Config{}
    decoder := json.NewDecoder(file)
    err = decoder.Decode(&conf)
    if (err != nil && err != io.EOF) {
        errLogger.Fatal("Could not decode config file " + configFilePath + ": ", err)
    }
    return &conf
}

// authHandler is used to generate an authentication header.
// The server expects VersionByte + TypeByte + IDToPassToAuthHandler.
func authHandler() string {
	if s := os.Getenv("KNOX_SSH_USER_AUTH"); s != "" {
        // For aarki the server uses underlying sshd for authentication and expects 
        // Version + Type + username + : + password
		return "0k" + s
	}
    if s:= os.Getenv("KNOX_PROMPT_USER_AUTH"); s != "" && s != "0" {
        // SSH authentication like above but prompts for user/pass
        reader := bufio.NewReader(os.Stdin)
        fmt.Print("Username: ")
        username, _ := reader.ReadString('\n')
        fmt.Print("Password: ")
        bytes, _ := terminal.ReadPassword(int(syscall.Stdin))
        password := string(bytes)
        fmt.Print("\n")
        return "0k" + strings.TrimSpace(username) + "@" + strings.TrimSpace(password)
    }
    return ""
    // Diable other types of auth for now
	//if s := os.Getenv("KNOX_USER_AUTH"); s != "" {
	//	return "0u" + s
	//}
	//if s := os.Getenv("KNOX_MACHINE_AUTH"); s != "" {
	//	c, _ := getCert()
	//	x509Cert, err := x509.ParseCertificate(c.Certificate[0])
	//	if err != nil {
	//		return "0t" + s
	//	}
	//	if len(x509Cert.Subject.CommonName) > 0 {
	//		return "0t" + x509Cert.Subject.CommonName
	//	} else if len(x509Cert.DNSNames) > 0 {
	//		return "0t" + x509Cert.DNSNames[0]
	//	} else {
	//		return "0t" + s
	//	}
	//}
	//if s := os.Getenv("KNOX_SERVICE_AUTH"); s != "" {
	//	return "0s" + s
	//}

	//u, err := user.Current()
	//if err != nil {
	//	return ""
	//}
	//d, err := ioutil.ReadFile(u.HomeDir + "/.knox_user_auth")
	//if err != nil {
	//	return ""
	//}
	//var authResp authTokenResp
	//err = json.Unmarshal(d, &authResp)
	//if err != nil {
	//	return ""
	//}

	//return "0u" + authResp.AccessToken
}

func main() {
	rand.Seed(time.Now().UTC().UnixNano())

	tlsConfig := &tls.Config{
		ServerName:         "knox",
		InsecureSkipVerify: true,
	}

	cert, err := getCert()
	if err == nil {
		tlsConfig.Certificates = []tls.Certificate{cert}
	}

    config := getConfig()

	cli := &knox.HTTPClient{
        Host:        config.ServerInfo.Name + ":" + config.ServerInfo.Port,
		AuthHandler: authHandler,
		KeyFolder:   keyFolder,
		Client:      &http.Client{Transport: &http.Transport{TLSClientConfig: tlsConfig}},
	}

	client.Run(cli, &client.VisibilityParams{log.Printf, log.Printf, func(map[string]uint64) {}}, tokenEndpoint, clientID)
}
